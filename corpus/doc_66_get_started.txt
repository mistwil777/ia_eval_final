Secondly, LangChain provides easy ways to incorporate these utilities into chains.Get started​Memory involves keeping a concept of state around throughout a user's interactions with an language model. A user's interactions with a language model are captured in the concept of ChatMessages, so this boils down to ingesting, capturing, transforming and extracting knowledge from a sequence of chat messages. There are many different ways to do this, each of which exists as its own memory type.In general, for each type of memory there are two ways to understanding using memory. These are the standalone functions which extract information from a sequence of messages, and then there is the way you can use this type of memory in a chain.Memory can return multiple pieces of information (for example, the most recent N messages and a summary of all previous messages). The returned information can either be a string or a list of messages.We will walk through the simplest form of memory: "buffer" memory, which just involves keeping a buffer of all prior messages. We will show how to use the modular utility functions here, then show how it can be used in a chain (both returning a string as well as a list of messages).ChatMessageHistory​One of the core utility classes underpinning most (if not all) memory modules is the ChatMessageHistory class. This is a super lightweight wrapper which exposes convenience methods for saving Human messages, AI messages, and then fetching them all.You may want to use this class directly if you are managing memory outside of a chain.from langchain.memory import ChatMessageHistoryhistory = ChatMessageHistory()history.add_user_message("hi!")history.add_ai_message("whats up?")history.messages    [HumanMessage(content='hi!', additional_kwargs={}),     AIMessage(content='whats up?', additional_kwargs={})]ConversationBufferMemory​We now show how to use this simple concept in a chain. We first showcase ConversationBufferMemory which is just a wrapper around