but more complex applications require chaining LLMs - either with each other or with other components.LangChain provides the Chain interface for such "chained" applications. We define a Chain very generically as a sequence of calls to components, which can include other chains. The base interface is simple:class Chain(BaseModel, ABC):    """Base interface that all chains should implement."""    memory: BaseMemory    callbacks: Callbacks    def __call__(        self,        inputs: Any,        return_only_outputs: bool = False,        callbacks: Callbacks = None,    ) -> Dict[str, Any]:        ...This idea of composing components together in a chain is simple but powerful. It drastically simplifies and makes more modular the implementation of complex applications, which in turn makes it much easier to debug, maintain, and improve your applications.For more specifics check out:How-to for walkthroughs of different chain featuresFoundational to get acquainted with core building block chainsDocument to learn how to incorporate documents into chainsPopular chains for the most common use casesAdditional to see some of the more advanced chains and integrations that you can use out of the boxWhy do we need chains?​Chains allow us to combine multiple components together to create a single, coherent application. For example, we can create a chain that takes user input, formats it with a PromptTemplate, and then passes the formatted response to an LLM. We can build more complex chains by combining multiple chains together, or by combining chains with other components.Get started​Using LLMChain​The LLMChain is most basic building block chain. It takes in a prompt template, formats it with the user input and returns the response from an LLM.To use the LLMChain, first create a prompt template.from